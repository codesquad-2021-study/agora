# 금주의 학습 키워드

## ❗️ GITHUB_TEMPLATE

root 폴더에 `.github` 폴더를 생성하고 내부에 관련 템플릿을 생성해 두면 issue, PR 시에 템플릿을 사용할 수 있다.

### ISSUE_TEMPLATE 

- issue 템플릿을 작성하기 위한 폴더. **파일명을 반드시 대문자로** 작성해야 함 (깃은 대소문자를 무시하기 때문에 유의해야한다.)
- 내부 {이슈 템플릿}.md 는 소문자로 작성해도 된다.

### PULL_REQUEST_TEMPLATE.md

- 이슈와 사용법은 같다. **파일명을 대문자로 작성**해야함을 주의하자 
- 
예시 

```markedonw
// feature_request.md

## 템플릿 제목 1

### 템플릿 소제목 1

### 템플릿 소제목 2 

```

- [템플릿을 적용해서 진행중인 이슈/PR](https://github.com/woowa-techcamp-2021/deal-19/issues)

<br/>
<hr/>

## ❗️ transpile / polyfill / bundle / plugin

### transpile

> 특정 동작을 하는 A의 문법을 B의 문법으로 변경한다

즉, 새로운 기술, API가 아닌 **문법 변환**이라는 것에 주의하자.

인간의 언어로 따지면 apple을 사과로 변경시키는 느낌이다.

- ex) const, let, class를 구 버전의 문법으로 변경

<br/>

### polyfill

> 신버전의 새로운 API를 구버전에서 사용할 수 있도록 지원한다.

즉, 구버전에는 존재하지 않는 새로운 함수, API 등을 구현해준다.

인간의 언어로 따지면 총이 뭔지 모르는 원주민에게 새총이라도 만들어서 "사냥을 한다"는 같은 목표를 이룰 수 있게 해주는 것이다. 

- ex) Promise, Map, Set 

### bundle 

> Dependency(의존성)을 확인하고, 하나의 번들로 만드는걸 목표로 한다.

#### 왜 필요한가?

- 이전 JS 모듈 시스템은 전역 오염이 일어나기 쉽고, 순서를 지켜야하며, 누가 누굴 의존하고 있는지 알기 힘들었다.

```
<script src="./a"/>
<script src="./b"/>
<script src="./c"/>
<script src="./d"/>
<script src="./e"/>
```

- SPA의 등장으로 ES Modules를 사용한다.
- 파일 수와 용량은 잦은 통신에 부담스럽다. (프론트엔드는 왜 빌드를 하는가?)

### plugins

> babel, webpack 등이 만들어낸 결과 파일에 **후속 처리**를 하기 위해 사용한다.

- 완성된 번들파일 난독화
- 특정 요소 추출 후 변경, 삭제 등..

#### 왜 한 번에 안 하고?

- 이 기능이 공식 명세에 들어가야하는 기능인가? 싶어서
- 후처리로 사용하는게 더 효율적이어서 

<br/>
<hr/>

## ❗️ middleware 

### 미들웨어를 사용하는 이유

- 서버의 공통관심사(수평, 횡단 관심사라고 한다)의 처리를 분리한다.

### 미들웨어 동작 방식

- 순서대로 동작하기에 순서가 중요하다
- 해당 서버의 모든 req, res가 미들웨어를 한 번 거치며 특정 처리를 하게 된다.
- 이 때 미들웨어가 정해둔 로직에 걸리면 res.send를 호출해서 미들웨어가 종료되면서 **요청을 멈추고 응답한다**
- 처리만 하고 아직 응답할 때가 아니면 next()로 다음 미들웨어에 req, res를 넘긴다.

<br/>
<hr/>

## 그 외에 해볼만한 고민들

- Webpack은 어떻게 구성되어 있을까? 동작 방식?

- plugins을 직접 만드려면 어떻게 해야할까?

- middleware는 어떻게 만드는걸까 
